# 第14章 设计游戏AI

到目前为止，在本书中，我们已经见识了一整套的AI技术，以及帮助AI继续发展的基础设施。我在第2章已提过，游戏 AI 开发是技术和基础设施的混合体，其中包含大量的临时解决方案、启发式方法和看起来很 hack 的代码位。

本章着眼于如何将所有bits应用到真实游戏中，以及如何应用技术来获得开发人员想要的游戏玩法。

通过对不同流派遍历的方式，我将研究玩家对游戏 AI 的期望以及其中存在的陷阱。 这里没有包含任何技术，只是说明如何应用本书其他地方的技术。 这里的分类相当高级和松散，有些游戏可能会被放置到不同的流派之中。 但是，从 AI 的角度来看，要实现的目标相对有限，因此我对流派进行了相应的分组。

在深入了解每种流派之前，有必要先了解一下在游戏中设计 AI 的一般过程。



## 14.1 设计

在本书中，我一直在使用相同的游戏 AI 模型，在图 14.1 中再次重复。 除了映射可能的技术外，此图还提供了设计 AI 时需要考虑的区域的计划。

在设计标题的 AI 时，团队通常会根据设计文档中描述的目标行为集进行工作。 AI 程序员（通常是 AI 技术负责人）制定出最简单的技术集来支持设计师的愿景。 如果某些事情特别困难，或者有简单的机会获得更复杂的结果，可能会导致反复修改。 一旦团队确信自己了解这些行为所施加的要求，就会选择技术来实现它们，以及将这些技术集成在一起的方法。 该结构已实现，包括计划中的 AI 与游戏引擎其余部分之间的集成层。 最初，角色用占位符填充，但随着基础设施到位，不同的开发人员或关卡设计师可以开始着手充实角色。

如果我可以自由支配一个项目，这当然是一个理想的行动计划。 现实中，您将面临来自许多不同方向的限制，这些限制会影响您的方法计划。 尤其是，由于需要发布不同进度的游戏预告，或是一个早期试玩版，一些基础的功能和行为在开发周期的早期就需要被实现。 在许多（即使不是大多数）项目中，像这样的内容只是为了进度里程碑而快速实施，然后在以后被删除和重写。 在大量项目中，快速而肮脏的代码被大量修补和 hack ，以至于最终无法完全移除而成为 AI 的一部分。

这类问题是该行业的正常部分，并且发生在每个人身上。 时间紧迫，资源有限，总有更多可以做的。 如果有一个游戏 AI 专家的秘密阴谋集团，你就不会因为不时发送被黑和半生不熟的 AI 代码而受到黑名单。 另一方面，质量确实受到关注：如果您提前考虑并构建可靠且有效的人工智能，您可以为您的职业生涯提供出色的服务。 阴谋集团一直在注视着。



### 14.1.1 例子

在本节中，我将通过一个示例来介绍假设游戏的两阶段设计需求（所需的行为和实现它们的技术）。 游戏从玩法上看很简单，但对 AI 的要求却多种多样。

我们的游戏被称为“鬼屋”，毫不奇怪，它是在一个鬼屋里设置的。 这是一个有名的鬼屋，四面八方的人都花钱来参观。 玩家拥有房子，玩家的工作是通过管理房子里的惊吓来让顾客付钱，确保游客得到他们正在寻找的幽灵。

访客到达房子，玩家的目标是让他们惊慌失措。 为此，玩家可以选择在房子里应用的幻影和机械技巧。 以前的访客不可避免地会分享他们的经历，而其他人会来寻求揭穿或模仿他们的恐惧。

玩家还必须尽量防止游客偶然发现房子的秘密、交易的诡计、单向镜子、烟雾机和幽灵的公共休息室。

这个想法的一个变体可以在 Ghost Master [177] 中看到，其中各种房屋与不同的居住者一起呈现。 住户不会害怕并过着自己的模拟人生般的生活。 它还与 Dungeon Keeper [90] 和 Evil Genius [110] 等游戏有相似之处。



### 14.1.2 评估行为

第一项任务是设计游戏中角色将显示的行为。 如果您正在开发自己的游戏，这可能是您对该项目的愿景的一部分。 如果你在开发工作室工作，那很可能是游戏设计师的工作。

虽然游戏的设计师会对游戏中的角色应该如何行动设定一些想法，但根据我的经验，这些想法很少是一成不变的。 通常，设计师不理解什么看起来微不足道，但真正困难的是（因此只有当它是游戏的中心点时才应该包括在内），以及许多看似困难但简单的添加可以改善角色行为。

游戏中角色的行为会随着您实施和尝试新事物而自然演变。 这不仅适用于具有长期研发阶段的业余爱好者项目或游戏； 具有固定想法和紧迫时间尺度的开发项目也是如此。 怀着世界上最好的意愿，在开始开发游戏之前，您不会完全了解游戏的 AI 需求。 值得从一开始就进行计划以获得一定程度的灵活性。

例如，使用游戏中的一组固定输入创建一个 AI 只是在项目结束时要求加班（它们无论如何都会发生，所以为什么要要求它们呢？）。 不可避免地，设计人员将需要在不方便的时候进行一些额外的 AI 输入，并且 AI 代码将需要重新编写。 正因为如此，在最初的实施计划中，最好在灵活性方面犯错，而不是在原始速度方面犯错。 后期优化比在最后一刻取消优化纠结的代码以维持灵活性要容易得多。
